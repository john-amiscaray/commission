{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nimport { FilesystemDirectory } from '../core-plugin-definitions';\n\nvar FilesystemPluginWeb =\n/** @class */\nfunction (_super) {\n  __extends(FilesystemPluginWeb, _super);\n\n  function FilesystemPluginWeb() {\n    var _this = _super.call(this, {\n      name: 'Filesystem',\n      platforms: ['web']\n    }) || this;\n\n    _this.DEFAULT_DIRECTORY = FilesystemDirectory.Data;\n    _this.DB_VERSION = 1;\n    _this.DB_NAME = 'Disc';\n    _this._writeCmds = ['add', 'put', 'delete'];\n    return _this;\n  }\n\n  FilesystemPluginWeb.prototype.initDb = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (this._db !== undefined) {\n          return [2\n          /*return*/\n          , this._db];\n        }\n\n        if (!('indexedDB' in window)) {\n          throw new Error('This browser doesn\\'t support IndexedDB');\n        }\n\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var request = indexedDB.open(_this.DB_NAME, _this.DB_VERSION);\n          request.onupgradeneeded = FilesystemPluginWeb.doUpgrade;\n\n          request.onsuccess = function () {\n            _this._db = request.result;\n            resolve(request.result);\n          };\n\n          request.onerror = function () {\n            return reject(request.error);\n          };\n\n          request.onblocked = function () {\n            console.warn('db blocked');\n          };\n        })];\n      });\n    });\n  };\n\n  FilesystemPluginWeb.doUpgrade = function (event) {\n    var eventTarget = event.target;\n    var db = eventTarget.result;\n\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default:\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n\n        var store = db.createObjectStore('FileStorage', {\n          keyPath: 'path'\n        });\n        store.createIndex('by_folder', 'folder');\n    }\n  };\n\n  FilesystemPluginWeb.prototype.dbRequest = function (cmd, args) {\n    return __awaiter(this, void 0, void 0, function () {\n      var readFlag;\n      return __generator(this, function (_a) {\n        readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return [2\n        /*return*/\n        , this.initDb().then(function (conn) {\n          return new Promise(function (resolve, reject) {\n            var tx = conn.transaction(['FileStorage'], readFlag);\n            var store = tx.objectStore('FileStorage');\n            var req = store[cmd].apply(store, args);\n\n            req.onsuccess = function () {\n              return resolve(req.result);\n            };\n\n            req.onerror = function () {\n              return reject(req.error);\n            };\n          });\n        })];\n      });\n    });\n  };\n\n  FilesystemPluginWeb.prototype.dbIndexRequest = function (indexName, cmd, args) {\n    return __awaiter(this, void 0, void 0, function () {\n      var readFlag;\n      return __generator(this, function (_a) {\n        readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return [2\n        /*return*/\n        , this.initDb().then(function (conn) {\n          return new Promise(function (resolve, reject) {\n            var tx = conn.transaction(['FileStorage'], readFlag);\n            var store = tx.objectStore('FileStorage');\n            var index = store.index(indexName);\n            var req = index[cmd].apply(index, args);\n\n            req.onsuccess = function () {\n              return resolve(req.result);\n            };\n\n            req.onerror = function () {\n              return reject(req.error);\n            };\n          });\n        })];\n      });\n    });\n  };\n\n  FilesystemPluginWeb.prototype.getPath = function (directory, uriPath) {\n    directory = directory || this.DEFAULT_DIRECTORY;\n    var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    var fsPath = '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  };\n\n  FilesystemPluginWeb.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var conn, tx, store;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.initDb()];\n\n          case 1:\n            conn = _a.sent();\n            tx = conn.transaction(['FileStorage'], 'readwrite');\n            store = tx.objectStore('FileStorage');\n            store.clear();\n            return [2\n            /*return*/\n            , {}];\n        }\n      });\n    });\n  };\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n\n\n  FilesystemPluginWeb.prototype.readFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 1:\n            entry = _a.sent();\n            if (entry === undefined) throw Error('File does not exist.');\n            return [2\n            /*return*/\n            , {\n              data: entry.content\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n\n\n  FilesystemPluginWeb.prototype.writeFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, data, doRecursive, occupiedEntry, encoding, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            data = options.data;\n            doRecursive = options.recursive;\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 1:\n            occupiedEntry = _a.sent();\n            if (occupiedEntry && occupiedEntry.type === 'directory') throw 'The supplied path is a directory.';\n            encoding = options.encoding;\n            parentPath = path.substr(0, path.lastIndexOf('/'));\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [parentPath])];\n\n          case 2:\n            parentEntry = _a.sent();\n            if (!(parentEntry === undefined)) return [3\n            /*break*/\n            , 4];\n            subDirIndex = parentPath.indexOf('/', 1);\n            if (!(subDirIndex !== -1)) return [3\n            /*break*/\n            , 4];\n            parentArgPath = parentPath.substr(subDirIndex);\n            return [4\n            /*yield*/\n            , this.mkdir({\n              path: parentArgPath,\n              directory: options.directory,\n              recursive: doRecursive\n            })];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            now = Date.now();\n            pathObj = {\n              path: path,\n              folder: parentPath,\n              type: 'file',\n              size: data.length,\n              ctime: now,\n              mtime: now,\n              content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data\n            };\n            return [4\n            /*yield*/\n            , this.dbRequest('put', [pathObj])];\n\n          case 5:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , {\n              uri: pathObj.path\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n\n\n  FilesystemPluginWeb.prototype.appendFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, data, parentPath, now, ctime, occupiedEntry, parentEntry, subDirIndex, parentArgPath, pathObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            data = options.data;\n            parentPath = path.substr(0, path.lastIndexOf('/'));\n            now = Date.now();\n            ctime = now;\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 1:\n            occupiedEntry = _a.sent();\n            if (occupiedEntry && occupiedEntry.type === 'directory') throw 'The supplied path is a directory.';\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [parentPath])];\n\n          case 2:\n            parentEntry = _a.sent();\n            if (!(parentEntry === undefined)) return [3\n            /*break*/\n            , 4];\n            subDirIndex = parentPath.indexOf('/', 1);\n            if (!(subDirIndex !== -1)) return [3\n            /*break*/\n            , 4];\n            parentArgPath = parentPath.substr(subDirIndex);\n            return [4\n            /*yield*/\n            , this.mkdir({\n              path: parentArgPath,\n              directory: options.directory,\n              recursive: true\n            })];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            if (occupiedEntry !== undefined) {\n              data = occupiedEntry.content + data;\n              ctime = occupiedEntry.ctime;\n            }\n\n            pathObj = {\n              path: path,\n              folder: parentPath,\n              type: 'file',\n              size: data.length,\n              ctime: ctime,\n              mtime: now,\n              content: data\n            };\n            return [4\n            /*yield*/\n            , this.dbRequest('put', [pathObj])];\n\n          case 5:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , {}];\n        }\n      });\n    });\n  };\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n\n\n  FilesystemPluginWeb.prototype.deleteFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry, entries;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 1:\n            entry = _a.sent();\n            if (entry === undefined) throw Error('File does not exist.');\n            return [4\n            /*yield*/\n            , this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n\n          case 2:\n            entries = _a.sent();\n            if (entries.length !== 0) throw Error('Folder is not empty.');\n            return [4\n            /*yield*/\n            , this.dbRequest('delete', [path])];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , {}];\n        }\n      });\n    });\n  };\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n\n\n  FilesystemPluginWeb.prototype.mkdir = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            doRecursive = options.recursive;\n            parentPath = path.substr(0, path.lastIndexOf('/'));\n            depth = (path.match(/\\//g) || []).length;\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [parentPath])];\n\n          case 1:\n            parentEntry = _a.sent();\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 2:\n            occupiedEntry = _a.sent();\n            if (depth === 1) throw Error('Cannot create Root directory');\n            if (occupiedEntry !== undefined) throw Error('Current directory does already exist.');\n            if (!doRecursive && depth !== 2 && parentEntry === undefined) throw Error('Parent directory must exist');\n            if (!(doRecursive && depth !== 2 && parentEntry === undefined)) return [3\n            /*break*/\n            , 4];\n            parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n            return [4\n            /*yield*/\n            , this.mkdir({\n              path: parentArgPath,\n              directory: options.directory,\n              recursive: doRecursive\n            })];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            now = Date.now();\n            pathObj = {\n              path: path,\n              folder: parentPath,\n              type: 'directory',\n              size: 0,\n              ctime: now,\n              mtime: now\n            };\n            return [4\n            /*yield*/\n            , this.dbRequest('put', [pathObj])];\n\n          case 5:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , {}];\n        }\n      });\n    });\n  };\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n\n\n  FilesystemPluginWeb.prototype.rmdir = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, directory, recursive, fullPath, entry, readDirResult, _i, _a, entry_1, entryPath, entryObj;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            path = options.path, directory = options.directory, recursive = options.recursive;\n            fullPath = this.getPath(directory, path);\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [fullPath])];\n\n          case 1:\n            entry = _b.sent();\n            if (entry === undefined) throw Error('Folder does not exist.');\n            if (entry.type !== 'directory') throw Error('Requested path is not a directory');\n            return [4\n            /*yield*/\n            , this.readdir({\n              path: path,\n              directory: directory\n            })];\n\n          case 2:\n            readDirResult = _b.sent();\n            if (readDirResult.files.length !== 0 && !recursive) throw Error('Folder is not empty');\n            _i = 0, _a = readDirResult.files;\n            _b.label = 3;\n\n          case 3:\n            if (!(_i < _a.length)) return [3\n            /*break*/\n            , 9];\n            entry_1 = _a[_i];\n            entryPath = path + \"/\" + entry_1;\n            return [4\n            /*yield*/\n            , this.stat({\n              path: entryPath,\n              directory: directory\n            })];\n\n          case 4:\n            entryObj = _b.sent();\n            if (!(entryObj.type === 'file')) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.deleteFile({\n              path: entryPath,\n              directory: directory\n            })];\n\n          case 5:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            return [4\n            /*yield*/\n            , this.rmdir({\n              path: entryPath,\n              directory: directory,\n              recursive: recursive\n            })];\n\n          case 7:\n            _b.sent();\n\n            _b.label = 8;\n\n          case 8:\n            _i++;\n            return [3\n            /*break*/\n            , 3];\n\n          case 9:\n            return [4\n            /*yield*/\n            , this.dbRequest('delete', [fullPath])];\n\n          case 10:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , {}];\n        }\n      });\n    });\n  };\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n\n\n  FilesystemPluginWeb.prototype.readdir = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry, entries, names;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 1:\n            entry = _a.sent();\n            if (options.path !== '' && entry === undefined) throw Error('Folder does not exist.');\n            return [4\n            /*yield*/\n            , this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n\n          case 2:\n            entries = _a.sent();\n            names = entries.map(function (e) {\n              return e.substring(path.length + 1);\n            });\n            return [2\n            /*return*/\n            , {\n              files: names\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n\n\n  FilesystemPluginWeb.prototype.getUri = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 1:\n            entry = _a.sent();\n            if (!(entry === undefined)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path + '/'])];\n\n          case 2:\n            entry = _a.sent();\n            _a.label = 3;\n\n          case 3:\n            if (entry === undefined) throw Error('Entry does not exist.');\n            return [2\n            /*return*/\n            , {\n              uri: entry.path\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n\n\n  FilesystemPluginWeb.prototype.stat = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path])];\n\n          case 1:\n            entry = _a.sent();\n            if (!(entry === undefined)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.dbRequest('get', [path + '/'])];\n\n          case 2:\n            entry = _a.sent();\n            _a.label = 3;\n\n          case 3:\n            if (entry === undefined) throw Error('Entry does not exist.');\n            return [2\n            /*return*/\n            , {\n              type: entry.type,\n              size: entry.size,\n              ctime: entry.ctime,\n              mtime: entry.mtime,\n              uri: entry.path\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n\n\n  FilesystemPluginWeb.prototype.rename = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._copy(options, true)];\n      });\n    });\n  };\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n\n\n  FilesystemPluginWeb.prototype.copy = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._copy(options, false)];\n      });\n    });\n  };\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n\n\n  FilesystemPluginWeb.prototype._copy = function (options, doRename) {\n    if (doRename === void 0) {\n      doRename = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var to, from, fromDirectory, toDirectory, fromPath, toPath, toObj, e_1, toPathComponents, toPath_1, toParentDirectory, fromObj, updateTime, _a, file, e_2, contents, _i, contents_1, filename;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            to = options.to, from = options.from, fromDirectory = options.directory, toDirectory = options.toDirectory;\n\n            if (!to || !from) {\n              throw Error('Both to and from must be provided');\n            } // If no \"to\" directory is provided, use the \"from\" directory\n\n\n            if (!toDirectory) {\n              toDirectory = fromDirectory;\n            }\n\n            fromPath = this.getPath(fromDirectory, from);\n            toPath = this.getPath(toDirectory, to); // Test that the \"to\" and \"from\" locations are different\n\n            if (fromPath === toPath) {\n              return [2\n              /*return*/\n              , {}];\n            }\n\n            if (toPath.startsWith(fromPath)) {\n              throw Error('To path cannot contain the from path');\n            }\n\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 6]);\n\n            return [4\n            /*yield*/\n            , this.stat({\n              path: to,\n              directory: toDirectory\n            })];\n\n          case 2:\n            toObj = _b.sent();\n            return [3\n            /*break*/\n            , 6];\n\n          case 3:\n            e_1 = _b.sent();\n            toPathComponents = to.split('/');\n            toPathComponents.pop();\n            toPath_1 = toPathComponents.join('/');\n            if (!(toPathComponents.length > 0)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.stat({\n              path: toPath_1,\n              directory: toDirectory\n            })];\n\n          case 4:\n            toParentDirectory = _b.sent();\n\n            if (toParentDirectory.type !== 'directory') {\n              throw new Error('Parent directory of the to path is a file');\n            }\n\n            _b.label = 5;\n\n          case 5:\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            // Cannot overwrite a directory\n            if (toObj && toObj.type === 'directory') {\n              throw new Error('Cannot overwrite a directory with a file');\n            }\n\n            return [4\n            /*yield*/\n            , this.stat({\n              path: from,\n              directory: fromDirectory\n            })];\n\n          case 7:\n            fromObj = _b.sent();\n\n            updateTime = function (path, ctime, mtime) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var fullPath, entry;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      fullPath = this.getPath(toDirectory, path);\n                      return [4\n                      /*yield*/\n                      , this.dbRequest('get', [fullPath])];\n\n                    case 1:\n                      entry = _a.sent();\n                      entry.ctime = ctime;\n                      entry.mtime = mtime;\n                      return [4\n                      /*yield*/\n                      , this.dbRequest('put', [entry])];\n\n                    case 2:\n                      _a.sent();\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            };\n\n            _a = fromObj.type;\n\n            switch (_a) {\n              case 'file':\n                return [3\n                /*break*/\n                , 8];\n\n              case 'directory':\n                return [3\n                /*break*/\n                , 15];\n            }\n\n            return [3\n            /*break*/\n            , 28];\n\n          case 8:\n            return [4\n            /*yield*/\n            , this.readFile({\n              path: from,\n              directory: fromDirectory\n            })];\n\n          case 9:\n            file = _b.sent();\n            if (!doRename) return [3\n            /*break*/\n            , 11];\n            return [4\n            /*yield*/\n            , this.deleteFile({\n              path: from,\n              directory: fromDirectory\n            })];\n\n          case 10:\n            _b.sent();\n\n            _b.label = 11;\n\n          case 11:\n            // Write the file to the new location\n            return [4\n            /*yield*/\n            , this.writeFile({\n              path: to,\n              directory: toDirectory,\n              data: file.data\n            })];\n\n          case 12:\n            // Write the file to the new location\n            _b.sent();\n\n            if (!doRename) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , updateTime(to, fromObj.ctime, fromObj.mtime)];\n\n          case 13:\n            _b.sent();\n\n            _b.label = 14;\n\n          case 14:\n            // Resolve promise\n            return [2\n            /*return*/\n            , {}];\n\n          case 15:\n            if (toObj) {\n              throw Error('Cannot move a directory over an existing object');\n            }\n\n            _b.label = 16;\n\n          case 16:\n            _b.trys.push([16, 20,, 21]); // Create the to directory\n\n\n            return [4\n            /*yield*/\n            , this.mkdir({\n              path: to,\n              directory: toDirectory,\n              recursive: false\n            })];\n\n          case 17:\n            // Create the to directory\n            _b.sent();\n\n            if (!doRename) return [3\n            /*break*/\n            , 19];\n            return [4\n            /*yield*/\n            , updateTime(to, fromObj.ctime, fromObj.mtime)];\n\n          case 18:\n            _b.sent();\n\n            _b.label = 19;\n\n          case 19:\n            return [3\n            /*break*/\n            , 21];\n\n          case 20:\n            e_2 = _b.sent();\n            return [3\n            /*break*/\n            , 21];\n\n          case 21:\n            return [4\n            /*yield*/\n            , this.readdir({\n              path: from,\n              directory: fromDirectory\n            })];\n\n          case 22:\n            contents = _b.sent().files;\n            _i = 0, contents_1 = contents;\n            _b.label = 23;\n\n          case 23:\n            if (!(_i < contents_1.length)) return [3\n            /*break*/\n            , 26];\n            filename = contents_1[_i]; // Move item from the from directory to the to directory\n\n            return [4\n            /*yield*/\n            , this._copy({\n              from: from + \"/\" + filename,\n              to: to + \"/\" + filename,\n              directory: fromDirectory,\n              toDirectory: toDirectory\n            }, doRename)];\n\n          case 24:\n            // Move item from the from directory to the to directory\n            _b.sent();\n\n            _b.label = 25;\n\n          case 25:\n            _i++;\n            return [3\n            /*break*/\n            , 23];\n\n          case 26:\n            if (!doRename) return [3\n            /*break*/\n            , 28];\n            return [4\n            /*yield*/\n            , this.rmdir({\n              path: from,\n              directory: fromDirectory\n            })];\n\n          case 27:\n            _b.sent();\n\n            _b.label = 28;\n\n          case 28:\n            return [2\n            /*return*/\n            , {}];\n        }\n      });\n    });\n  };\n\n  FilesystemPluginWeb._debug = true;\n  return FilesystemPluginWeb;\n}(WebPlugin);\n\nexport { FilesystemPluginWeb };\nvar Filesystem = new FilesystemPluginWeb();\nexport { Filesystem }; //# sourceMappingURL=filesystem.js.map","map":null,"metadata":{},"sourceType":"module"}