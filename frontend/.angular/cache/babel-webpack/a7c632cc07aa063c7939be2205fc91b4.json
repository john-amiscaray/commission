{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport { filter, share, take } from 'rxjs/operators';\nimport { Client } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state';\n/**\n * This is the main Stomp Client.\n * Typically you will create an instance of this to connect to the STOMP broker.\n *\n * This wraps [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n * {@link Client} class.\n *\n * The key difference is that it exposes operations as RxJS Observables.\n * For example when a STOMP endpoint is subscribed it returns an Observable\n * that will stream all received messages.\n *\n * With exception of beforeConnect, functionality related to all callbacks in\n * [@stomp/stompjs Client]{@link Client}\n * is exposed as Observables/Subjects/BehaviorSubjects.\n *\n * RxStomp also tries to transparently handle connection failures.\n *\n * Part of `@stomp/rx-stomp`\n */\n\nexport class RxStomp {\n  /**\n   * Constructor\n   */\n  constructor() {\n    /**\n     * Internal array to hold locally queued messages when STOMP broker is not connected.\n     */\n    this._queuedMessages = [];\n    this._stompClient = new Client();\n\n    const noOp = () => {}; // Before connect is no op by default\n\n\n    this._beforeConnect = noOp; // debug is no-op by default\n\n    this._debug = noOp; // Initial state is CLOSED\n\n    this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n    this._connectedPre$ = this._connectionStatePre$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    })); // Initial state is CLOSED\n\n    this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n    this.connected$ = this.connectionState$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    })); // Setup sending queuedMessages\n\n    this.connected$.subscribe(() => {\n      this._sendQueuedMessages();\n    });\n    this._serverHeadersBehaviourSubject$ = new BehaviorSubject(null);\n    this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter(headers => {\n      return headers !== null;\n    }));\n    this.stompErrors$ = new Subject();\n    this.unhandledMessage$ = new Subject();\n    this.unhandledReceipts$ = new Subject();\n    this.unhandledFrame$ = new Subject();\n    this.webSocketErrors$ = new Subject();\n  }\n  /**\n   * Instance of actual\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n   * {@link Client}.\n   *\n   * **Be careful in calling methods on it directly - you may get unintended consequences.**\n   */\n\n\n  get stompClient() {\n    return this._stompClient;\n  }\n  /**\n   * Set configuration. This method may be called multiple times.\n   * Each call will add to the existing configuration.\n   *\n   * Example:\n   *\n   * ```javascript\n   *        const rxStomp = new RxStomp();\n   *        rxStomp.configure({\n   *          brokerURL: 'ws://127.0.0.1:15674/ws',\n   *          connectHeaders: {\n   *            login: 'guest',\n   *            passcode: 'guest'\n   *          },\n   *          heartbeatIncoming: 0,\n   *          heartbeatOutgoing: 20000,\n   *          reconnectDelay: 200,\n   *          debug: (msg: string): void => {\n   *            console.log(new Date(), msg);\n   *          }\n   *        });\n   *        rxStomp.activate();\n   * ```\n   *\n   * Maps to: [Client#configure]{@link Client#configure}\n   */\n\n\n  configure(rxStompConfig) {\n    const stompConfig = Object.assign({}, rxStompConfig);\n\n    if (stompConfig.beforeConnect) {\n      this._beforeConnect = stompConfig.beforeConnect;\n      delete stompConfig.beforeConnect;\n    } // RxStompConfig has subset of StompConfig fields\n\n\n    this._stompClient.configure(stompConfig);\n\n    if (stompConfig.debug) {\n      this._debug = stompConfig.debug;\n    }\n  }\n  /**\n   * Initiate the connection with the broker.\n   * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\n   * it will keep trying to reconnect.\n   *\n   * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\n   *\n   * Maps to: [Client#activate]{@link Client#activate}\n   */\n\n\n  activate() {\n    this._stompClient.configure({\n      beforeConnect: () => __awaiter(this, void 0, void 0, function* () {\n        this._changeState(RxStompState.CONNECTING); // Call handler\n\n\n        yield this._beforeConnect(this);\n      }),\n      onConnect: frame => {\n        this._serverHeadersBehaviourSubject$.next(frame.headers); // Indicate our connected state to observers\n\n\n        this._changeState(RxStompState.OPEN);\n      },\n      onStompError: frame => {\n        // Trigger the frame subject\n        this.stompErrors$.next(frame);\n      },\n      onWebSocketClose: () => {\n        this._changeState(RxStompState.CLOSED);\n      },\n      onUnhandledMessage: message => {\n        this.unhandledMessage$.next(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.unhandledReceipts$.next(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.unhandledFrame$.next(frame);\n      },\n      onWebSocketError: evt => {\n        this.webSocketErrors$.next(evt);\n      }\n    }); // Attempt connection\n\n\n    this._stompClient.activate();\n  }\n  /**\n   * Disconnect if connected and stop auto reconnect loop.\n   * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n   *\n   * To reactivate you can call [RxStomp#activate]{@link RxStomp#activate}.\n   *\n   * Maps to: [Client#deactivate]{@link Client#deactivate}\n   */\n\n\n  deactivate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._changeState(RxStompState.CLOSING); // The promise will be resolved immediately if there are no active connection\n      // otherwise, after it has successfully disconnected.\n\n\n      yield this._stompClient.deactivate();\n\n      this._changeState(RxStompState.CLOSED);\n    });\n  }\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n\n\n  connected() {\n    return this.connectionState$.getValue() === RxStompState.OPEN;\n  }\n  /**\n   * If the client is active (connected or going to reconnect).\n   *\n   *  Maps to: [Client#active]{@link Client#active}\n   */\n\n\n  get active() {\n    return this.stompClient.active;\n  }\n  /**\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations.\n   *\n   * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n   *\n   * `body` must be String.\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\n   *\n   * To send a binary message body use binaryBody parameter. It should be a\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   * Sometimes brokers may not support binary frames out of the box.\n   * Please check your broker documentation.\n   *\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n   * For binary messages `content-length` header is always added.\n   *\n   * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n   * and `content-length` header is missing.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   * If you do not want that behavior,\n   * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\n   * in the parameters.\n   * When `false`, this function will raise an error if message could not be sent immediately.\n   *\n   * Maps to: [Client#publish]{@link Client#publish}\n   *\n   * See: {@link IRxStompPublishParams} and {@link IPublishParams}\n   *\n   * ```javascript\n   *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n   *\n   *        // Only destination is mandatory parameter\n   *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n   *\n   *        // Skip content-length header in the frame to the broker\n   *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n   *\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n   *        // setting content-type header is not mandatory, however a good practice\n   *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\n   *                         headers: {'content-type': 'application/octet-stream'}});\n   * ```\n   */\n\n\n  publish(parameters) {\n    // retry behaviour is defaulted to true\n    const shouldRetry = parameters.retryIfDisconnected == null ? true : parameters.retryIfDisconnected;\n\n    if (this.connected()) {\n      this._stompClient.publish(parameters);\n    } else if (shouldRetry) {\n      this._debug(`Not connected, queueing`);\n\n      this._queuedMessages.push(parameters);\n    } else {\n      throw new Error('Cannot publish while broker is not connected');\n    }\n  }\n  /** It will send queued messages. */\n\n\n  _sendQueuedMessages() {\n    const queuedMessages = this._queuedMessages;\n    this._queuedMessages = [];\n\n    if (queuedMessages.length === 0) {\n      return;\n    }\n\n    this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n\n    for (const queuedMessage of queuedMessages) {\n      this._debug(`Attempting to send ${queuedMessage}`);\n\n      this.publish(queuedMessage);\n    }\n  }\n\n  watch(opts, headers = {}) {\n    const defaults = {\n      subHeaders: {},\n      unsubHeaders: {},\n      subscribeOnlyOnce: false\n    };\n    let params;\n\n    if (typeof opts === 'string') {\n      params = Object.assign({}, defaults, {\n        destination: opts,\n        subHeaders: headers\n      });\n    } else {\n      params = Object.assign({}, defaults, opts);\n    }\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n\n\n    this._debug(`Request to subscribe ${params.destination}`);\n\n    const coldObservable = Observable.create(messages => {\n      /*\n       * These variables will be used as part of the closure and work their magic during unsubscribe\n       */\n      let stompSubscription; // Stomp\n\n      let stompConnectedSubscription; // RxJS\n\n      let connectedPre$ = this._connectedPre$;\n\n      if (params.subscribeOnlyOnce) {\n        connectedPre$ = connectedPre$.pipe(take(1));\n      }\n\n      stompConnectedSubscription = connectedPre$.subscribe(() => {\n        this._debug(`Will subscribe to ${params.destination}`);\n\n        let subHeaders = params.subHeaders;\n\n        if (typeof subHeaders === 'function') {\n          subHeaders = subHeaders();\n        }\n\n        stompSubscription = this._stompClient.subscribe(params.destination, message => {\n          messages.next(message);\n        }, subHeaders);\n      });\n      return () => {\n        /* cleanup function, will be called when no subscribers are left */\n        this._debug(`Stop watching connection state (for ${params.destination})`);\n\n        stompConnectedSubscription.unsubscribe();\n\n        if (this.connected()) {\n          this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n\n          let unsubHeaders = params.unsubHeaders;\n\n          if (typeof unsubHeaders === 'function') {\n            unsubHeaders = unsubHeaders();\n          }\n\n          stompSubscription.unsubscribe(unsubHeaders);\n        } else {\n          this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n        }\n      };\n    });\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n\n    return coldObservable.pipe(share());\n  }\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n   * random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based in the value of the receipt-id.\n   *\n   * This method allow watching for a receipt and invoke the callback\n   * when corresponding receipt has been received.\n   *\n   * The actual {@link Frame}\n   * will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Publishing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        rxStomp.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\n   * ```\n   *\n   * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n   */\n\n\n  watchForReceipt(receiptId, callback) {\n    this._stompClient.watchForReceipt(receiptId, callback);\n  }\n\n  _changeState(state) {\n    this._connectionStatePre$.next(state);\n\n    this.connectionState$.next(state);\n  }\n\n} //# sourceMappingURL=rx-stomp.js.map","map":null,"metadata":{},"sourceType":"module"}