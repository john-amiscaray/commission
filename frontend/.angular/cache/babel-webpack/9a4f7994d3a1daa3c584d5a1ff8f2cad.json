{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { filter, first } from 'rxjs/operators';\nimport { UUID } from 'angular2-uuid';\n/**\n * An implementation of Remote Procedure Call (RPC) using messaging.\n *\n * Please see the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for details.\n *\n * Part of `@stomp/rx-stomp`\n */\n\nexport class RxStompRPC {\n  /**\n   * Create an instance, see the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for details.\n   */\n  constructor(rxStomp, stompRPCConfig) {\n    this.rxStomp = rxStomp;\n    this.stompRPCConfig = stompRPCConfig;\n    this._replyQueueName = '/temp-queue/rpc-replies';\n\n    this._setupReplyQueue = () => {\n      return this.rxStomp.unhandledMessage$;\n    };\n\n    this._customReplyQueue = false;\n\n    if (stompRPCConfig) {\n      if (stompRPCConfig.replyQueueName) {\n        this._replyQueueName = stompRPCConfig.replyQueueName;\n      }\n\n      if (stompRPCConfig.setupReplyQueue) {\n        this._customReplyQueue = true;\n        this._setupReplyQueue = stompRPCConfig.setupReplyQueue;\n      }\n    }\n  }\n  /**\n   * Make an RPC request.\n   * See the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for example.\n   *\n   * It is a simple wrapper around [RxStompRPC#stream]{@link RxStompRPC#stream}.\n   */\n\n\n  rpc(params) {\n    // We know there will be only one message in reply\n    return this.stream(params).pipe(first());\n  }\n  /**\n   * Make an RPC stream request. See the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html).\n   *\n   * Note: This call internally takes care of generating a correlation id,\n   * however, if `correlation-id` is passed via `headers`, that will be used instead.\n   */\n\n\n  stream(params) {\n    const headers = Object.assign({}, params.headers || {});\n    const {\n      destination,\n      body,\n      binaryBody\n    } = params;\n\n    if (!this._repliesObservable) {\n      const repliesObservable = this._setupReplyQueue(this._replyQueueName, this.rxStomp); // In case of custom queue, ensure it remains subscribed\n\n\n      if (this._customReplyQueue) {\n        this._dummySubscription = repliesObservable.subscribe(() => {});\n      }\n\n      this._repliesObservable = repliesObservable;\n    }\n\n    return Observable.create(rpcObserver => {\n      let defaultMessagesSubscription;\n      const correlationId = headers['correlation-id'] || UUID.UUID();\n      defaultMessagesSubscription = this._repliesObservable.pipe(filter(message => {\n        return message.headers['correlation-id'] === correlationId;\n      })).subscribe(message => {\n        rpcObserver.next(message);\n      }); // send an RPC request\n\n      headers['reply-to'] = this._replyQueueName;\n      headers['correlation-id'] = correlationId;\n      this.rxStomp.publish({\n        destination,\n        body,\n        binaryBody,\n        headers\n      });\n      return () => {\n        // Cleanup\n        defaultMessagesSubscription.unsubscribe();\n      };\n    });\n  }\n\n} //# sourceMappingURL=rx-stomp-rpc.js.map","map":null,"metadata":{},"sourceType":"module"}